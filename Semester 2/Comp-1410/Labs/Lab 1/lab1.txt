

        This is for main function and generate_num function.
The way I set up this program was 4 separate functions + 1 function that just holds the test cases I wrote so as
to keep the program clean enough to read. The main function just controls the calling of the separate functions
like the generate_num function. This function will constantly make random numbers between -2147483647 to 2147483647
Which I explain in at the top of the program in more depth the only number it will ignore is 0 which is why I have
a written assert for 0. I also have comments explaining the function of each line in the function


        This is for the recursive function.
The digit_sum_recursive function will take a number and just look to see if it is negative or positive then hold the
result in it while sending the absolute number over to the digit_sum_recursive_recurse function where it will then
begin the process of recursion first checking if the number is less then 10 which if it is will return the current
number ending the recursion as at this point every part of the recursion is sitting on the return statement leaving no
more chance for the function to recurse the number again. If the number is greater then 10 however the program will
begin by dividing n by 10 and flooring it removing the last digit.
(This whole process is because I completely forgot about the remainder system and am too lazy to fix it since this works)
It then subtract the current number from the original number leaving the last digit as the remainder. The remainder is
added to the return and digit_sum_recursive_recurse is called again with the number missing its last digit being pushed
starting the next stack of the recursion. It will do this until a number is less then 10 where it will go back through
the stack frame adding up all the previously found digits finally getting back to the original call and sending the
number back to digit_sum_recursive where it is multiplied by -1 if it went in as a negative. I was too lazy to fit the
negative section into the actual recursive function when it failed a couple time.


        This is for the iterative function.
The digit_sum_iterative function will first check if negative, then will go onto an if else statement to find the count
of digits in the number via log. It will then enter a for loop where it will go as long as digits exist. It will divide
by 10 on the number and floor it then subtract the original number from the modified number getting the missing digit
and replace the original number with the current number after adding the difference into the variable which will send
the sum of digits back to the assert. It will do this until the i is greater then the size of the very original number
and will then exit the loop where it will then check if a negative was caught at the beginning. If a negative was caught
the sum will be changed to a negative and then returned.


        The hidden_function function
Holds all the asserts for cleaner viewing not much to say pretty straight forward


        Some things to look for I guess?
The total message you should receive at the end of the programs execution is

Starting program now, it will begin by generating and testing TEST_CASE cases
All TEST_CASE test cases randomly generated by the program have been successful now onto the specific tests.
All tests passed successfully.

Now onto the much longer set of test cases going to TEST_CASE_2 cases
All TEST_CASE_2 test cases from the second group randomly generated by the program have been successful
The testing has concluded.
All Tests Successful.

These are some prints that I added to say if each section ran properly if Some aren't showing up something failed
TEST_CASE and TEST_CASE_2 should both be numbers not words but they can be changed pre execution.