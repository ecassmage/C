/*
==============================================================================
COMP-1410 Lab 1: Iteration and Recursion
==============================================================================
Student name: Evan Morrison

Cite any other sources of outside help
(e.g., websites, other students):
Technically got the idea to make the program work with negatives from Isaac.
But I coded it on my own.

==============================================================================
 */

/* 
==============================================================================


              HaHa, My program can test any number between
                       -2147483647 to 2147483647
 For negative numbers I am assuming that if a number is negative every digit
        Is also negative so -12345 would be -1-2-3-4-5 not -1+2+3+4+5
This Program has been tested in both repl.it and onlinegdb.

I have also tested this inside Notepad++ (I have a compiler connected to Notepad++
 as well as Clion which is connected to C99 also called ISO/IEC 9899:1999 which
    which is not the most recent version of C (Most recent version is C11)
                        I'll switch to C11 in the future


==============================================================================
*/

/*****************************************************************************
Note that if you don't want to wait around you might want to change the defined
 TEST_CASE_2 to a different number as it will attempt to push 2 billion
 numbers through the functions
 The 2 billion cases should take at most 5 minutes
*****************************************************************************/
#include<stdio.h>
#include<assert.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
void hidden_function();
signed int generate_num(int *summed);
// digit_sum_iterative(n) returns the decimal sum of the digits in n
// requires: 0 <= n < 10^9
// note: implemented using iteration and not recursion
signed int digit_sum_iterative(int n);

// digit_sum_recursive(n) returns the decimal sum of the digits in n
// requires: 0 <= n < 10^9
// note: implemented using recursion and not iteration
signed int digit_sum_recursive(int n);
signed int digit_sum_recursive_recurse(signed int n);
#define TEST_CASES 50000
// Sadly Online Compilers can't handle 2 billion and end up tripping outofMemory exit code 9 and so I was forced to lower it to 2 million
// If while testing this program the compiler gives an exit code 9 this is an outofMemory error and not an incorrect logic error.
#define TEST_CASES_2 2000000


int main(void){
    printf("Starting program now, it will begin by generating and testing %d cases\n", TEST_CASES);
    /***** This entire section is just to stress test the program in every way conceivable with a program that hold no bias. *****/
    signed int value_not_rand;
    int value_assert;
    for (int i = 0; i < TEST_CASES; i++) { // This is how many numbers are going to be tested
        value_not_rand = generate_num(&value_assert);
        assert(digit_sum_iterative(value_not_rand) == value_assert); // This asserts the made number and summed digits
        assert(digit_sum_recursive(value_not_rand) == value_assert); // This asserts the made number and summed digits
    }
    /***** This entire section is just to stress test the program in every way conceivable with a program that hold no bias. *****/

    printf("All %d test cases randomly generated by the program have been successful "
           "now onto the specific tests.\n", TEST_CASES);
    // Implement your test code here
    hidden_function(); // Goes to a function holding a few test cases, out of the way for cleaner organization
    printf("All tests passed successfully.\n\nNow onto the much longer set of test "
           "cases going to %d cases\n", TEST_CASES_2);

    /***** This entire section is just to stress test the program in every way conceivable with a program that hold no bias. *****/
    int go_for_it = 2;
    int cleanUp;
    while (go_for_it != 1 && go_for_it != 0){
        printf("Do you want to allow the program to check another %d cases?\n(1 for yes, 0 for no): ", TEST_CASES_2);
        scanf(" %d", &go_for_it);
        while ((cleanUp = getchar()) != '\n'){}
    }
    printf("Okay we will do as you inputted. You inputted: %d\n", go_for_it);
    if (go_for_it == 1){
        for (int i = 0; i < TEST_CASES_2; i++) { // This is how many numbers are going to be tested
            value_not_rand = generate_num(&value_assert);
            assert(digit_sum_iterative(value_not_rand) ==
                   value_assert); // This asserts the made number and summed digits
            assert(digit_sum_recursive(value_not_rand) ==
                   value_assert); // This asserts the made number and summed digits
        }
        printf("All %d test cases from the second group randomly generated by the program have been successful", TEST_CASES_2);
    }
    /***** This entire section is just to stress test the program in every way conceivable with a program that hold no bias. *****/
    printf("\nThe testing has concluded.\nAll Tests Successful.\n");
}


signed int generate_num(int *summed){

    srand(time(NULL)); // This Generates a seed based on time so that numbers are a little random
    signed int rando = rand() % 10; // This chooses a random amount of digits between 0 and 9 digits can chosen
    signed int value_not_rand = rand() % 19 - 9; // This adds the first digit to the variable for negatives to be created properly
    signed int value_assert = value_not_rand; // This is the added together digits that will be given its value as the loop goes on this will be what the assert checks for accuracy
    for (int i = 1; i < rando; i++){ // For loop for what the current digit being generated is
        signed int value_added = rand() % 10; // This will generate the current digit for the number
        value_not_rand *= 10; // this moves the already chosen digits to the left by 1 digit to make space for the next digit
        if (value_not_rand >= 0){ // This checks if this current number will be a positive or negative number
            value_not_rand += value_added; // This adds the digit to the number
            value_assert += value_added; // This sums the digit with the rest of the digits
        }
        else{ // This checks if this current number will be a positive or negative number
            value_not_rand -= value_added; // This adds the digit to the number
            value_assert -= value_added; // This sums the digit with the rest of the digits
        }
    }
    *summed = value_assert; // Send the summed digits back via pointer reference
    return value_not_rand; // Return the number via a return statement

}


signed int digit_sum_recursive(signed int n){ // The check if the number is negative or not
    // This entire Function will keep track of the sign of the digit for the recursive function. Doing everything in
    // a single function wasn't working and I didn't feel like spending so much time on it so I just came to a compromise
    // with a second function to be used.
    int negative = 0;
    if (n < 0){
        negative = 1;
        n = abs(n);
    }
    if (negative == 1){
        return -1 * digit_sum_recursive_recurse(n); // return for negatives
    }
    return digit_sum_recursive_recurse(n); // return for positives
}


signed int digit_sum_recursive_recurse(signed int n){
    //ended up having to do this since finding the sum of digits wasn't working in its own program if I also wanted to
    // find the sum of digits if negative
    if (n < 10){
        return n; // the end of the recursion and the beginning of the unwinding
    }
    int num = floor(n/10);
    int hold = n - (num*10);
    return hold + digit_sum_recursive_recurse(num); // The Calling a new stack of Recursion
}


signed int digit_sum_iterative(signed int n){ // The iterative function
    int size;
    int negative = 0;
    if (n < 0){
        negative = 1;
        n = abs(n);
    }
    if (n > 10){
        size = floor(log10(n) + 1);
    }
    else
        size = 1;
    int num;
    int hold = 0;
    for (int i = 0; i <= size; i++){ // will iterate over each digit inside this for loop
        num = floor(n/10);
        hold += n - (num * 10);
        n = num;
    }
    if (negative == 1){
        hold *= -1;
    }
    return hold;
}


void hidden_function(){ // Asserts that I wrote
    assert(!digit_sum_iterative(0));
    assert(!digit_sum_recursive(0));
    assert(digit_sum_iterative(0) == 0);
    assert(digit_sum_recursive(0) == 0);
    assert(digit_sum_iterative(123456789) == 45);
    assert(digit_sum_recursive(123456789) == 45);
    assert(digit_sum_iterative(999999999) == 81);
    assert(digit_sum_recursive(999999999) == 81);
    assert(digit_sum_iterative(1234) == 10);
    assert(digit_sum_recursive(1234) == 10);
    assert(digit_sum_iterative (3453) == 15);
    assert(digit_sum_recursive (3453) == 15);
    assert(digit_sum_iterative (3534) == 15);
    assert(digit_sum_recursive (3534) == 15);
    assert(digit_sum_iterative (97876) == 37);
    assert(digit_sum_recursive (97876) == 37);
    assert(digit_sum_iterative (5) == 5);
    assert(digit_sum_recursive (5) == 5);
    assert(digit_sum_iterative (2147483647) == 46);
    assert(digit_sum_recursive (2147483647) == 46);
    assert(digit_sum_iterative (-2147483647) == -46);
    assert(digit_sum_recursive (-2147483647) == -46);
    assert(digit_sum_iterative (-1122) == -6);
    assert(digit_sum_recursive (-1122) == -6);
}